"""Convert Playwright Python code to Robot Framework Browser library syntax."""

import re
from typing import List, Dict, Tuple, Optional


class PlaywrightToRobotConverter:
    """Converts Playwright Python code to Robot Framework test cases."""

    def __init__(self):
        """Initialize the converter with keyword mappings."""
        self.indent = "    "
        self.action_mappings = {
            "goto": self._convert_goto,
            "click": self._convert_click,
            "fill": self._convert_fill,
            "press": self._convert_press,
            "select_option": self._convert_select_option,
            "check": self._convert_check,
            "uncheck": self._convert_uncheck,
            "hover": self._convert_hover,
            "dblclick": self._convert_dblclick,
            "set_input_files": self._convert_set_input_files,
            "get_by_role": self._convert_locator,
            "get_by_text": self._convert_locator,
            "get_by_label": self._convert_locator,
            "get_by_placeholder": self._convert_locator,
            "get_by_test_id": self._convert_locator,
            "locator": self._convert_locator,
            "wait_for_load_state": self._convert_wait_for_load_state,
            "screenshot": self._convert_screenshot,
            "expect_visible": self._convert_expect_visible,
            "expect_text": self._convert_expect_text,
            "expect_value": self._convert_expect_value,
            "expect_checked": self._convert_expect_checked,
            "expect_url": self._convert_expect_url,
            "expect_title": self._convert_expect_title,
        }

    def convert(
        self,
        playwright_code: str,
        test_name: str = "Recorded Test",
        suite_name: str = "Recorded Test Suite",
        browser: str = "chromium",
        headless: bool = False,
    ) -> str:
        """Convert Playwright code to Robot Framework test.

        Args:
            playwright_code: Python code generated by Playwright codegen
            test_name: Name for the test case
            suite_name: Name for the test suite
            browser: Browser type (chromium, firefox, webkit)
            headless: Whether to run in headless mode

        Returns:
            Robot Framework test case as a string
        """
        actions = self._parse_playwright_code(playwright_code)
        robot_test = self._generate_robot_test(
            actions=actions,
            test_name=test_name,
            suite_name=suite_name,
            browser=browser,
            headless=headless,
        )
        return robot_test

    def _parse_playwright_code(self, code: str) -> List[Dict]:
        """Parse Playwright Python code and extract actions.

        Args:
            code: Playwright Python code

        Returns:
            List of action dictionaries
        """
        actions = []
        lines = code.split("\n")

        for line in lines:
            line = line.strip()
            if not line or line.startswith("#") or line.startswith("import"):
                continue

            if "page.goto(" in line:
                url = self._extract_string_arg(line)
                if url:
                    actions.append({"type": "goto", "url": url})

            elif ".click(" in line:
                selector = self._extract_selector(line)
                if selector:
                    actions.append({"type": "click", "selector": selector})

            elif ".fill(" in line:
                selector, value = self._extract_fill_args(line)
                if selector and value:
                    actions.append({"type": "fill", "selector": selector, "value": value})

            elif ".press(" in line:
                selector, key = self._extract_press_args(line)
                if selector and key:
                    actions.append({"type": "press", "selector": selector, "key": key})

            elif ".select_option(" in line:
                selector, value = self._extract_select_args(line)
                if selector and value:
                    actions.append({"type": "select_option", "selector": selector, "value": value})

            elif ".check(" in line:
                selector = self._extract_selector(line)
                if selector:
                    actions.append({"type": "check", "selector": selector})

            elif ".uncheck(" in line:
                selector = self._extract_selector(line)
                if selector:
                    actions.append({"type": "uncheck", "selector": selector})

            elif ".hover(" in line:
                selector = self._extract_selector(line)
                if selector:
                    actions.append({"type": "hover", "selector": selector})

            elif ".dblclick(" in line:
                selector = self._extract_selector(line)
                if selector:
                    actions.append({"type": "dblclick", "selector": selector})

            elif ".set_input_files(" in line or ".setInputFiles(" in line:
                selector, file_path = self._extract_set_input_files_args(line)
                if selector and file_path:
                    actions.append(
                        {"type": "set_input_files", "selector": selector, "file_path": file_path}
                    )

            elif "screenshot(" in line:
                path = self._extract_string_arg(line, arg_name="path")
                if path:
                    actions.append({"type": "screenshot", "path": path})

            elif "wait_for_load_state(" in line:
                state = self._extract_string_arg(line) or "networkidle"
                actions.append({"type": "wait_for_load_state", "state": state})

            elif "expect(" in line:
                # Handle Playwright expect assertions
                if ".to_be_visible()" in line:
                    selector = self._extract_expect_selector(line)
                    if selector:
                        actions.append({"type": "expect_visible", "selector": selector})

                elif ".to_have_text(" in line or ".to_contain_text(" in line:
                    selector = self._extract_expect_selector(line)
                    text = self._extract_expect_text_value(line)
                    if selector and text:
                        actions.append({"type": "expect_text", "selector": selector, "text": text})

                elif ".to_have_value(" in line:
                    selector = self._extract_expect_selector(line)
                    value = self._extract_expect_text_value(line)
                    if selector and value:
                        actions.append(
                            {"type": "expect_value", "selector": selector, "value": value}
                        )

                elif ".to_be_checked()" in line:
                    selector = self._extract_expect_selector(line)
                    if selector:
                        actions.append({"type": "expect_checked", "selector": selector})

                elif ".to_have_url(" in line:
                    url = self._extract_expect_text_value(line)
                    if url:
                        actions.append({"type": "expect_url", "url": url})

                elif ".to_have_title(" in line:
                    title = self._extract_expect_text_value(line)
                    if title:
                        actions.append({"type": "expect_title", "title": title})

        return actions

    def _extract_string_arg(self, line: str, arg_name: Optional[str] = None) -> Optional[str]:
        """Extract a string argument from a function call."""
        if arg_name:
            pattern = rf'{arg_name}=["\']([^"\']+)["\']'
        else:
            pattern = r'["\']([^"\']+)["\']'

        match = re.search(pattern, line)
        return match.group(1) if match else None

    def _extract_selector(self, line: str) -> Optional[str]:
        """Extract selector from a Playwright action, handling chained locators.

        Converts chained locators to Robot Framework >> syntax:
        page.get_by_role("row").get_by_role("link") -> role=row >> role=link
        """
        # Find all locator methods in the line
        locator_patterns = [
            (r'locator\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)', lambda s: s),
            (
                (
                    r'get_by_role\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']'
                    r'(?:,\s*name=["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\'])?\)'
                ),
                lambda s, n=None: f'role={s}[name="{n}"]' if n else f"role={s}",
            ),
            (r'get_by_text\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)', lambda s: f"text={s}"),
            (r'get_by_label\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)', lambda s: s),
            (
                r'get_by_placeholder\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)',
                lambda s: f"placeholder={s}",
            ),
            (
                r'get_by_test_id\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)',
                lambda s: f"data-testid={s}",
            ),
        ]

        selectors = []

        for pattern_str, formatter in locator_patterns:
            pattern = re.compile(pattern_str)
            for match in pattern.finditer(line):
                groups = match.groups()
                # Unescape
                groups = tuple(
                    g.replace(r"\"", '"').replace(r"\'", "'") if g else None for g in groups
                )
                selector = formatter(*groups)
                selectors.append(selector)

        if selectors:
            # Chain selectors with >>
            return " >> ".join(selectors)

        # Fallback pattern
        match = re.search(r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)', line)
        if match:
            selector = match.group(1)
            selector = selector.replace(r"\"", '"').replace(r"\'", "'")
            return selector

        return None

    def _extract_fill_args(self, line: str) -> Tuple[Optional[str], Optional[str]]:
        """Extract selector and value from fill action.

        Handles both:
        - page.fill("selector", "value")
        - page.locator("selector").fill("value")
        """
        parts = line.split(".fill(")
        if len(parts) > 1:
            # First check for locator chain: page.locator("selector").fill("value")
            selector = self._extract_selector(line)
            if selector:
                # Extract the fill value (single argument)
                value_pattern = r'\.fill\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
                value_match = re.search(value_pattern, line)
                if value_match:
                    value = value_match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                    return selector, value

            # Fallback: Check for page.fill("selector", "value")
            pattern = (
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\s*,\s*'
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
            )
            match = re.search(pattern, parts[1])
            if match:
                selector = match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                value = match.group(2).replace(r"\"", '"').replace(r"\'", "'")
                return selector, value
        return None, None

    def _extract_press_args(self, line: str) -> Tuple[Optional[str], Optional[str]]:
        """Extract selector and key from press action."""
        # Extract both selector and key from .press(selector, key)
        parts = line.split(".press(")
        if len(parts) > 1:
            # Match two quoted strings: .press("selector", "key")
            pattern = (
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\s*,\s*'
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
            )
            match = re.search(pattern, parts[1])
            if match:
                selector = match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                key = match.group(2).replace(r"\"", '"').replace(r"\'", "'")
                return selector, key
        return None, None

    def _extract_select_args(self, line: str) -> Tuple[Optional[str], Optional[str]]:
        """Extract selector and value from select_option action.

        Handles both:
        - page.select_option("selector", "value")
        - page.locator("selector").select_option("value")
        """
        parts = line.split(".select_option(")
        if len(parts) > 1:
            # First check for locator chain: page.locator("selector").select_option("value")
            selector = self._extract_selector(line)
            if selector:
                # Extract the select value (single argument)
                value_pattern = r'\.select_option\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
                value_match = re.search(value_pattern, line)
                if value_match:
                    value = value_match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                    return selector, value

            # Fallback: Check for page.select_option("selector", "value")
            pattern = (
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\s*,\s*'
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
            )
            match = re.search(pattern, parts[1])
            if match:
                selector = match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                value = match.group(2).replace(r"\"", '"').replace(r"\'", "'")
                return selector, value
        return None, None

    def _extract_set_input_files_args(self, line: str) -> Tuple[Optional[str], Optional[str]]:
        """Extract selector and file path from set_input_files action.

        Handles both:
        - page.set_input_files("selector", "file.pdf")
        - page.locator("selector").set_input_files("file.pdf")
        """
        parts = line.split(".set_input_files(") or line.split(".setInputFiles(")
        if len(parts) > 1:
            # First check for locator chain
            selector = self._extract_selector(line)
            if selector:
                # Extract the file path (single argument)
                file_pattern = r'\.set_input_files\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
                file_match = re.search(file_pattern, line)
                if not file_match:
                    file_pattern = r'\.setInputFiles\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
                    file_match = re.search(file_pattern, line)
                if file_match:
                    file_path = file_match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                    return selector, file_path

            # Fallback: Check for page.set_input_files("selector", "file")
            pattern = (
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\s*,\s*'
                r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\)'
            )
            match = re.search(pattern, parts[1])
            if match:
                selector = match.group(1).replace(r"\"", '"').replace(r"\'", "'")
                file_path = match.group(2).replace(r"\"", '"').replace(r"\'", "'")
                return selector, file_path
        return None, None

    def _extract_expect_selector(self, line: str) -> Optional[str]:
        """Extract selector from expect() statement.

        Handles: expect(page.locator("selector")).to_be_visible()
        """
        # Pattern: expect(page.locator("selector") or expect(locator)
        patterns = [
            r'expect\(page\.locator\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']',
            r'expect\(page\.get_by_[a-z_]+\(["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']',
        ]

        for pattern in patterns:
            match = re.search(pattern, line)
            if match:
                selector = match.group(1)
                selector = selector.replace(r"\"", '"').replace(r"\'", "'")
                return selector
        return None

    def _extract_expect_text_value(self, line: str) -> Optional[str]:
        """Extract text/value from expect assertion.

        Handles: .to_have_text("value") or .to_contain_text("value")
        """
        # Find the last quoted string in the line (the assertion value)
        pattern = r'["\']([^"\'\\]*(?:\\.[^"\'\\]*)*)["\']\s*\)'
        matches = list(re.finditer(pattern, line))
        if matches:
            # Get the last match (the assertion value, not the selector)
            value = matches[-1].group(1)
            value = value.replace(r"\"", '"').replace(r"\'", "'")
            return value
        return None

    def _simplify_selector(self, selector: str) -> str:
        """Simplify selector for Robot Framework syntax.

        Converts:
        - [data-test="value"] -> data-test=value
        - [id="value"] -> id=value
        - Other bracket selectors with quotes -> remove quotes
        """
        import re

        # Pattern for [attribute="value"] or [attribute='value']
        match = re.match(r'^\[([a-zA-Z-]+)=["\']([^"\']+)["\']\]$', selector)
        if match:
            attr, value = match.groups()
            return f"{attr}={value}"

        # Pattern for removing quotes from bracket selectors
        # e.g., [data-test="value"] -> [data-test=value]
        selector = re.sub(r'\[([a-zA-Z-]+)=["\']([^"\']+)["\']\]', r"[\1=\2]", selector)

        return selector

    def _convert_goto(self, action: Dict) -> str:
        """Convert goto action to Robot Framework."""
        url = action.get("url", "")
        return f"New Page{self.indent}{url}"

    def _convert_click(self, action: Dict) -> str:
        """Convert click action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Click{self.indent}{selector}"

    def _convert_fill(self, action: Dict) -> str:
        """Convert fill action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        value = action.get("value", "")
        return f"Type Text{self.indent}{selector}{self.indent}{value}"

    def _convert_press(self, action: Dict) -> str:
        """Convert press action to Robot Framework."""
        key = action.get("key", "")
        return f"Keyboard Key{self.indent}press{self.indent}{key}"

    def _convert_select_option(self, action: Dict) -> str:
        """Convert select_option to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        value = action.get("value", "")
        return f"Select Options By{self.indent}{selector}{self.indent}value{self.indent}{value}"

    def _convert_check(self, action: Dict) -> str:
        """Convert check action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Check Checkbox{self.indent}{selector}"

    def _convert_uncheck(self, action: Dict) -> str:
        """Convert uncheck action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Uncheck Checkbox{self.indent}{selector}"

    def _convert_hover(self, action: Dict) -> str:
        """Convert hover action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Hover{self.indent}{selector}"

    def _convert_dblclick(self, action: Dict) -> str:
        """Convert double-click action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Click{self.indent}{selector}{self.indent}clickCount=2"

    def _convert_set_input_files(self, action: Dict) -> str:
        """Convert set_input_files action to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        file_path = action.get("file_path", "")
        return f"Upload File By Selector{self.indent}{selector}{self.indent}{file_path}"

    def _convert_wait_for_load_state(self, action: Dict) -> str:
        """Convert wait_for_load_state to Robot Framework."""
        state = action.get("state", "networkidle")
        return f"Wait For Load State{self.indent}{state}"

    def _convert_screenshot(self, action: Dict) -> str:
        """Convert screenshot action to Robot Framework."""
        path = action.get("path", "screenshot.png")
        return f"Take Screenshot{self.indent}{path}"

    def _convert_expect_visible(self, action: Dict) -> str:
        """Convert expect visible assertion to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Get Element States{self.indent}{selector}{self.indent}validate{self.indent}visible"

    def _convert_expect_text(self, action: Dict) -> str:
        """Convert expect text assertion to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        text = action.get("text", "")
        return f"Get Text{self.indent}{selector}{self.indent}=={self.indent}{text}"

    def _convert_expect_value(self, action: Dict) -> str:
        """Convert expect value assertion to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        value = action.get("value", "")
        return (
            f"Get Property{self.indent}{selector}{self.indent}"
            f"value{self.indent}=={self.indent}{value}"
        )

    def _convert_expect_checked(self, action: Dict) -> str:
        """Convert expect checked assertion to Robot Framework."""
        selector = self._simplify_selector(action.get("selector", ""))
        return f"Get Checkbox State{self.indent}{selector}{self.indent}=={self.indent}checked"

    def _convert_expect_url(self, action: Dict) -> str:
        """Convert expect URL assertion to Robot Framework."""
        url = action.get("url", "")
        return f"Get Url{self.indent}=={self.indent}{url}"

    def _convert_expect_title(self, action: Dict) -> str:
        """Convert expect title assertion to Robot Framework."""
        title = action.get("title", "")
        return f"Get Title{self.indent}=={self.indent}{title}"

    def _convert_locator(self, action: Dict) -> str:
        """Handle locator-based actions."""
        return ""

    def _generate_robot_test(
        self,
        actions: List[Dict],
        test_name: str,
        suite_name: str,
        browser: str,
        headless: bool,
    ) -> str:
        """Generate complete Robot Framework test file.

        Args:
            actions: List of parsed actions
            test_name: Test case name
            suite_name: Test suite name
            browser: Browser type
            headless: Headless mode flag

        Returns:
            Complete Robot Framework test as string
        """
        lines = [
            "*** Settings ***",
            "Library    Browser",
            "",
            "",
            "*** Test Cases ***",
            test_name,
        ]

        lines.append(
            f"{self.indent}New Browser{self.indent}{browser}{self.indent}headless={headless}"
        )
        lines.append(
            f"{self.indent}New Context{self.indent}viewport={{'width': 1920, 'height': 1080}}"
        )

        for action in actions:
            action_type = action.get("type")
            if action_type in self.action_mappings:
                converter = self.action_mappings[action_type]
                robot_line = converter(action)
                if robot_line:
                    lines.append(f"{self.indent}{robot_line}")

        lines.append("")
        return "\n".join(lines)
